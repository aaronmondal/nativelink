{
  lib,
  # TODO(aaronmondal): Make this generic over llvm triples.
  nixSystemToRustTargets,
  writeShellScriptBin,
  nix2container,
  lre,
}: let
  copyright = ''
    # Copyright 2024 The NativeLink Authors. All rights reserved.
    #
    # Licensed under the Apache License, Version 2.0 (the "License");
    # you may not use this file except in compliance with the License.
    # You may obtain a copy of the License at
    #
    #    http://www.apache.org/licenses/LICENSE-2.0
    #
    # Unless required by applicable law or agreed to in writing, software
    # distributed under the License is distributed on an "AS IS" BASIS,
    # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    # See the License for the specific language governing permissions and
    # limitations under the License.

    # This file is @generated by lre-cc.
  '';

  systems = [
    "aarch64-darwin"
    "aarch64-linux"
    "x86_64-darwin"
    "x86_64-linux"
  ];
  compilers = [
    "clang"
    # TODO(aaronmondal): "gcc"
  ];

  makeRepoDefinition = system: compiler: ''
    ${" "}   new_local_repository(
    ${" "}       name = "lre-cc-clang-${system}",
    ${" "}       build_file = "@local-remote-execution//cc:${system}-clang.BUILD.bazel",
    ${" "}       path = "$(nix eval .#packages.${system}.cc.cc.outPath --raw)",
    ${" "}   )
    ${" "}   new_local_repository(
    ${" "}       name = "lre-cc-libclang-${system}",
    ${" "}       build_file = "@local-remote-execution//cc:${system}-libclang.BUILD.bazel",
    ${" "}       path = "$(nix eval .#packages.${system}.cc.cc.lib.outPath --raw)",
    ${" "}   )
    ${" "}   new_local_repository(
    ${" "}       name = "lre-cc-llvm-${system}",
    ${" "}       build_file = "@local-remote-execution//cc:${system}-llvm.BUILD.bazel",
    ${" "}       path = "$(nix eval .#packages.${system}.llvm.outPath --raw)",
    ${" "}   )
  '';

  allRepoDefinitions = lib.concatStrings (lib.flatten (
    map (system: map (compiler: makeRepoDefinition system compiler) compilers) systems
  ));

  clangBuildFile = system: let
    ccTargets = nixSystemToRustTargets.${system};
  in ''
    ${copyright}
    """Unwrapped cross-compatible clang for lre-cc executing on ${system}."""

    load("@rules_cc//cc/toolchains:tool.bzl", "cc_tool")

    cc_tool(
        name = "clang",
        src = "bin/clang",
        data = [
            "@lre-cc-libclang-${system}//:exec_platform_builtin_headers",
            "@lre-cc-libclang-${system}//:exec_platform_multicall_support_files",
        ],
    )

    cc_tool(
        name = "clang++",
        src = "bin/clang++",
        data = [
            "@lre-cc-libclang-${system}//:exec_platform_builtin_headers",
            "@lre-cc-libclang-${system}//:exec_platform_multicall_support_files",
        ],
    )

    cc_tool(
        name = "clang-tidy",
        src = "bin/clang-tidy",
        data = [
            "@lre-cc-libclang-${system}//:exec_platform_builtin_headers",
            "@lre-cc-libclang-${system}//:exec_platform_multicall_support_files",
        ],
    )'';

  libClangBuildFile = system: let
  in ''
    ${copyright}
    """Tool repository for lre-cc executing on ${system}."""

    filegroup(
        name = "exec_builtin_headers",
        srcs = glob([
            "lib/clang/19/include/**",
        ]),
        visibility = ["//visibility:public"],
    )

    filegroup(
        name = "exec_linker_builtins",
        srcs = glob([
            "lib/**/*.a",
            "lib/**/*.so",
            "lib/**/*.o",
        ]),
        visibility = ["//visibility:public"],
    )'';

  llvmBuildFile = system: let
  in ''
    """Tool repository for llvm tools executing on ${system}."""

    load("@rules_cc//cc/toolchains:tool.bzl", "cc_tool")

    [
        cc_tool(
            name = name,
            src = "bin/{}".format(name),
            data = [":exec_platform_multicall_support_files"],
        )
        for name in [
            "llvm-ar",
            "llvm-libtool-darwin",
            "llvm-objcopy",
            "llvm-objdump",
            "llvm-cov",
            "llvm-strip",
        ]
    ]'';

  buildFile = system: let
    ccTargets = nixSystemToRustTargets.${system};
    # Generate select entry for a target
    # mkSelectEntry = target: ''
    #   ${" "}       "@local-remote-execution//cc/triple:${target}": glob([
    #   ${" "}           "bin/*.so",
    #   ${" "}           "lib/*.so",
    #   ${" "}           "lib/rustlib/${target}/codegen-backends/*.so",
    #   ${" "}           "lib/rustlib/${target}/bin/rust-lld",
    #   ${" "}           "lib/rustlib/${target}/lib/*.so",
    #   ${" "}       ]),'';
    # Generate stdlib select entry for a target
    # mkStdlibSelectEntry = target:
    #   ''
    #     ${" "}       "@local-remote-execution//rust/triple:${target}": glob([
    #     ${" "}           "lib/rustlib/${target}/lib/*.rlib",
    #     ${" "}           "lib/rustlib/${target}/lib/*.so",
    #     ${" "}           "lib/rustlib/${target}/lib/*.a",''
    #   + (lib.optionalString (builtins.match ".*-musl" target != null)
    #     ''${"\n "}           "lib/rustlib/${target}/lib/self-contained/**",'')
    #   + ''${"\n "}       ]),'';
    # selectEntries = builtins.concatStringsSep "\n" (map mkSelectEntry ccTargets);
    # stdlibSelectEntries = builtins.concatStringsSep "\n" (map mkStdlibSelectEntry ccTargets);
  in ''
    ${copyright}
    """Tool repository for lre-cc executing on ${system}."""

    load("@rules_cc//cc/toolchains:tool.bzl", "cc_tool")
    load("@rules_cc//cc/toolchains:tool_map.bzl", "cc_tool_map")

    # This select happens under the target configuration. For macOS,
    # llvm-libtool-darwin should be used when creating static libraries even if
    # the exec platform is linux.
    alias(
        name = "all_tools",
        actual = select({
            "@platforms//os:macos": ":macos_tools",
            "//conditions:default": ":default_tools",
        }),
        visibility = ["//visibility:public"],
    )

    COMMON_TOOLS = {
        "@rules_cc//cc/toolchains/actions:assembly_actions": ":clang",
        "@rules_cc//cc/toolchains/actions:c_compile": ":clang",
        "@rules_cc//cc/toolchains/actions:cpp_compile_actions": ":clang++",
        "@rules_cc//cc/toolchains/actions:link_actions": ":lld",
        "@rules_cc//cc/toolchains/actions:objcopy_embed_data": ":llvm-objcopy",
        "@rules_cc//cc/toolchains/actions:strip": ":llvm-strip",
    }

    cc_tool_map(
        name = "default_tools",
        tools = COMMON_TOOLS | {
            "@rules_cc//cc/toolchains/actions:ar_actions": ":llvm-ar",
        },
        visibility = ["//visibility:private"],
    )

    cc_tool_map(
        name = "macos_tools",
        tools = COMMON_TOOLS | {
            "@rules_cc//cc/toolchains/actions:ar_actions": ":llvm-libtool-darwin",
        },
        visibility = ["//visibility:private"],
    )'';

  lre-cc-configs-gen = writeShellScriptBin "lre-cc" ''
    set -euo pipefail

    SRC_ROOT=$(git rev-parse --show-toplevel)/local-remote-execution

    cd "''${SRC_ROOT}"

    cat > ''${SRC_ROOT}/cc/extension.bzl << EOF
    ${copyright}
    """Module extension to register different lre-cc tool repositories."""

    load("@bazel_tools//tools/build_defs/repo:local.bzl", "new_local_repository")

    def _lre_cc_impl(_mctx):
    ${allRepoDefinitions}
    lre_cc = module_extension(implementation = _lre_cc_impl)
    EOF

    cat > ''${SRC_ROOT}/cc/platforms/BUILD.bazel << EOF
    ${copyright}
    # Some toolchains, like the darwin ones, don't have an actual container
    # image. We still map them to the output of the tag of the corresponding
    # theoretical worker image so that bare metal metal workers can advertise
    # exact exec_properties to schedulers.

    platform(
        name = "aarch64-apple-darwin",
        exec_properties = {
            # nix eval .#packages.aarch64-darwin.nativelink-worker-lre-cc.imageTag
            "lre-cc": $(nix eval .#packages.aarch64-darwin.nativelink-worker-lre-cc.imageTag),
        },
        parents = ["@local-remote-execution//platforms:aarch64-darwin"],
    )

    platform(
        name = "aarch64-unknown-linux-gnu",
        constraint_values = ["@local-remote-execution//libc:glibc"],
        exec_properties = {
            # nix eval .#packages.aarch64-linux.nativelink-worker-lre-cc.imageTag
            "lre-cc": $(nix eval .#packages.aarch64-linux.nativelink-worker-lre-cc.imageTag),
        },
        parents = ["@local-remote-execution//platforms:aarch64-linux"],
    )

    platform(
        name = "aarch64-unknown-linux-musl",
        constraint_values = ["@local-remote-execution//libc:musl"],
        exec_properties = {
            # nix eval .#packages.aarch64-linux.nativelink-worker-lre-cc.imageTag
            "lre-cc": $(nix eval .#packages.aarch64-linux.nativelink-worker-lre-cc.imageTag),
        },
        parents = ["@local-remote-execution//platforms:aarch64-linux"],
    )

    platform(
        name = "x86_64-apple-darwin",
        exec_properties = {
            # nix eval .#packages.x86_64-darwin.nativelink-worker-lre-cc.imageTag
            "lre-cc": $(nix eval .#packages.x86_64-darwin.nativelink-worker-lre-cc.imageTag),
        },
        parents = ["@local-remote-execution//platforms:x86_64-darwin"],
    )

    platform(
        name = "x86_64-unknown-linux-gnu",
        constraint_values = ["@local-remote-execution//libc:glibc"],
        exec_properties = {
            # nix eval .#packages.x86_64-linux.nativelink-worker-lre-cc.imageTag
            "lre-cc": $(nix eval .#packages.x86_64-linux.nativelink-worker-lre-cc.imageTag),
        },
        parents = ["@local-remote-execution//platforms:x86_64-linux"],
    )

    platform(
        name = "x86_64-unknown-linux-musl",
        constraint_values = ["@local-remote-execution//libc:musl"],
        exec_properties = {
            # nix eval .#packages.x86_64-linux.nativelink-worker-lre-cc.imageTag
            "lre-cc": $(nix eval .#packages.x86_64-linux.nativelink-worker-lre-cc.imageTag),
        },
        parents = ["@local-remote-execution//platforms:x86_64-linux"],
    )
    EOF

    # Unwrapped clang

    cat > ''${SRC_ROOT}/cc/aarch64-darwin-clang.BUILD.bazel << EOF
    ${clangBuildFile "aarch64-darwin"}
    EOF

    cat > ''${SRC_ROOT}/cc/aarch64-linux-clang.BUILD.bazel << EOF
    ${clangBuildFile "aarch64-linux"}
    EOF

    cat > ''${SRC_ROOT}/cc/x86_64-darwin-clang.BUILD.bazel << EOF
    ${clangBuildFile "x86_64-darwin"}
    EOF

    cat > ''${SRC_ROOT}/cc/x86_64-linux-clang.BUILD.bazel << EOF
    ${clangBuildFile "x86_64-linux"}
    EOF

    # Libclang

    cat > ''${SRC_ROOT}/cc/aarch64-darwin-libclang.BUILD.bazel << EOF
    ${libClangBuildFile "aarch64-darwin"}
    EOF

    cat > ''${SRC_ROOT}/cc/aarch64-linux-libclang.BUILD.bazel << EOF
    ${libClangBuildFile "aarch64-linux"}
    EOF

    cat > ''${SRC_ROOT}/cc/x86_64-darwin-libclang.BUILD.bazel << EOF
    ${libClangBuildFile "x86_64-darwin"}
    EOF

    cat > ''${SRC_ROOT}/cc/x86_64-linux-libclang.BUILD.bazel << EOF
    ${libClangBuildFile "x86_64-linux"}
    EOF

    # LLVM

    cat > ''${SRC_ROOT}/cc/aarch64-darwin-llvm.BUILD.bazel << EOF
    ${llvmBuildFile "aarch64-darwin"}
    EOF

    cat > ''${SRC_ROOT}/cc/aarch64-linux-llvm.BUILD.bazel << EOF
    ${llvmBuildFile "aarch64-linux"}
    EOF

    cat > ''${SRC_ROOT}/cc/x86_64-darwin-llvm.BUILD.bazel << EOF
    ${llvmBuildFile "x86_64-darwin"}
    EOF

    cat > ''${SRC_ROOT}/cc/x86_64-linux-llvm.BUILD.bazel << EOF
    ${llvmBuildFile "x86_64-linux"}
    EOF

    # Linker

    cat > ''${SRC_ROOT}/cc/aarch64-darwin-lld.BUILD.bazel << EOF
    ${lldBuildFile "aarch64-darwin"}
    EOF

    cat > ''${SRC_ROOT}/cc/aarch64-linux-mold.BUILD.bazel << EOF
    ${moldBuildFile "aarch64-linux"}
    EOF

    cat > ''${SRC_ROOT}/cc/x86_64-darwin-lld.BUILD.bazel << EOF
    ${lldBuildFile "x86_64-darwin"}
    EOF

    cat > ''${SRC_ROOT}/cc/x86_64-linux-mold.BUILD.bazel << EOF
    ${moldBuildFile "x86_64-linux"}
    EOF'';

  Env = [
    # Add all tooling here so that the generated toolchains use `/nix/store/*`
    # paths instead of `/bin` or `/usr/bin`. This way we're guaranteed to use
    # binary identical toolchains during local and remote execution.
    # ("PATH="
    #   + (lib.strings.concatStringsSep ":" [
    #     "${lre.stdenv.cc.bintools}/bin"
    #     "${lre.clang}/bin"
    #     "${lre.stdenv}/bin"
    #     "${coreutils}/bin"
    #     "${findutils}/bin"
    #     "${gnutar}/bin"
    #   ]))

    "CC=${lre.stdenv.cc}/bin/clang"
  ];

  image = nix2container.buildImage {
    name = "lre-cc";
    maxLayers = 100;
    config = {inherit Env;};
    # Passthrough so that other images can reuse the environment.
    meta = {inherit Env;};

    # Don't set a tag here so that the image is tagged by its derivation hash.
    # tag = null;
  };
in {
  inherit lre-cc-configs-gen image;
  meta = {inherit Env;};
}
# TODO(aaronmondal): Port this.
# cc_tool(
#     name = "lld",
#     src = select({
#         "//constraint:linux_aarch64": "@clang-linux-aarch64//:bin/clang++",
#         "//constraint:linux_x86_64": "@clang-linux-x86_64//:bin/clang++",
#     }),
#     data = [
#         ":exec_platform_linker_builtins",
#         ":exec_platform_multicall_support_files",
#     ],
# )
